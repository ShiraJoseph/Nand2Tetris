class Equation {
	field int degree;
	field boolean xExists, yExists, bExists, mExists, xIsScreenCutoff, startLineNegative, isPerpendicular, isVertical, isHorizontal, isXAxis, isYAxis;
	field String format;
	field Fraction xF, yF, bF, mF, scale;
	static Fraction xCalc, yCalc, bCalc, newSlope, newB, mx, tempCalc1, tempCalc2, tempCalc3, tempCalc4, tempCalc5;
	static Int calc1, calc2, calc3, calc4, calc5, calc6;

	/** Constructs a new equation for graphing */
	constructor Equation new(int deg, String form) {
		let xExists = false;
		let yExists = false;
		let bExists = false;
		let mExists = false;
		let isVertical = false;
		let isHorizontal = false;
		let isXAxis = false;
		let isYAxis = false;
		let scale = Fraction.new(Const.i1(), Const.i1());
		let degree = deg;
		let format = form;
		return this;
	}

	/** Initializes static variables */
	function void init() {
		let xCalc = Fraction.new(Const.i1(), Const.i1());
		let yCalc = Fraction.new(Const.i1(), Const.i1());
		let bCalc = Fraction.new(Const.i1(), Const.i1());
		let newSlope = Fraction.new(Const.i1(), Const.i1());
		let newB = Fraction.new(Const.i1(), Const.i1());
		let mx = Fraction.new(Const.i1(), Const.i1());
		let tempCalc1 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc2 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc3 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc4 = Fraction.new(Const.i1(), Const.i1());
		let tempCalc5 = Fraction.new(Const.i1(), Const.i1());
		let calc1 = Int.new(true, 1);
		let calc2 = Int.new(true, 1);
		let calc3 = Int.new(true, 1);
		let calc4 = Int.new(true, 1);
		let calc5 = Int.new(true, 1);
		let calc6 = Int.new(true, 1);
		return;
	}

	/** Disposes static variables */
	function void deInit() {
		do xCalc.dispose();
		do yCalc.dispose();
		do bCalc.dispose();
		do newSlope.dispose();
		do newB.dispose();
		do mx.dispose();
		do tempCalc1.dispose();
		do tempCalc2.dispose();
		do tempCalc3.dispose();
		do tempCalc4.dispose();
		do tempCalc5.dispose();
		do calc1.dispose();
		do calc2.dispose();
		do calc3.dispose();
		do calc4.dispose();
		do calc5.dispose();
		do calc6.dispose();
		return;
	}

	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	/** Accessors */
	method int degree(){ return degree; }
	method Fraction x(){ return xF; }
	method Fraction y(){ return yF; }
	method Fraction b(){ return bF; }
	method Fraction slope(){ return mF; }
	method Fraction scale(){ return scale; }
	method boolean xIsScreenCutoff(){ return xIsScreenCutoff; }
	method boolean startLineNegative(){ return startLineNegative; }
	method boolean isPerpendicular(){
		if(isVertical | isHorizontal){
			return true;
		}
		return false;
	}
	method boolean isVertical(){ return isVertical; }
	method boolean isHorizontal(){ return isHorizontal; }
	method boolean isXAxis(){ return isXAxis; }
	method boolean isYAxis(){ return isYAxis; }
	method String format(){ return format; }
	method void setDegree(int deg){
		let degree = deg;
		return;
	}
	method void setX(Fraction xSet){
		let xF = xSet;
		let xExists = true;
		return;
	}
	method void setY(Fraction ySet){
		let yF = ySet;
		let yExists = true;
		return;
	}
	method void setB(Fraction bSet){
		let bF = bSet;
		let bExists = true;
		return;
	}
	method void setSlope(Fraction mSet){
		let mF = mSet;
		let mExists = true;
		return;
	}
	method void setScale(Fraction sSet){
		let scale = sSet;
		return;
	}
	method void setXIsScreenCutoff(boolean isX){
		let xIsScreenCutoff = isX;
		return;
	}
	method void setStartLineNegative(boolean startNegative){
		let startLineNegative = startNegative;
		return;
	}
	method void setIsVertical(boolean setVert){
		let isVertical = setVert;
		return;
	}
	method void setIsHorizontal(boolean setHor){
		let isHorizontal = setHor;
		return;
	}
	method void setIsXAxis(boolean setXAxis){
		let isXAxis = setXAxis;
		return;
	}
	method void setIsYAxis(boolean setYAxis){
		let isYAxis = setYAxis;
		return;
	}

	/** Turns an equation in the standard or point-slope format into one using the slope-intercept format */
  function Equation convertToSlopeIntercept(Equation e){
    var String f;
    let f = e.format();
    if (S.equals(f, Const.sI())){
      return Equation.setSlopeInterceptDirection(e);
    }
    if (S.equals(f, Const.sP())){
      return Equation.convertFromPointSlopeToSlopeIntercept(e);
    }
    if (S.equals(f, Const.sS())){
      return Equation.convertFromStandardToSlopeIntercept(e);
    }
    return e;
  }

	function Equation setSlopeInterceptDirection(Equation e){
		var Fraction slope, b;
		let slope = e.slope();
		let b = e.b();
		if (slope.equals(Const.f0())){
      do e.setIsHorizontal(true);
      if (b.equals(Const.f0())){
        do e.setIsXAxis(true);
      }
    }
    return e;
	}

	function Equation convertFromPointSlopeToSlopeIntercept(Equation oldE){
		var Equation newE;
		var Fraction O;

		let xCalc = oldE.x();
    let yCalc = oldE.y();
    let newE = Equation.new(1, Const.sI());
    let newSlope = oldE.slope();
    let O = Const.f0();

		// slope remains the same
    do newE.setSlope(newSlope);

		// none of x, y, or m are 0; y = mx + y1 - mx1
    if (~(newSlope.equals(O) | xCalc.equals(O) | yCalc.equals(O))){
      do Fraction.multiply(newSlope, xCalc, mx, calc1, calc2, calc3, calc4, calc5, calc6);
      do yCalc.minus(mx, calc1);
      do newE.setB(calc1);
      return newE;
    }

		// x and/or m is 0; y = mx + y1
    if (xCalc.equals(O) | newSlope.equals(O)){
      do newE.setB(yCalc);
      if (newSlope.equals(O)){ // m is 0; y = y1
        do newE.setIsHorizontal(true);
        if (yCalc.equals(O)){ // m and y are 0; y = 0
          do newE.setIsXAxis(true);
        }
      }
      return newE;
    }
		// just y is 0; y = mx - mx1
    do Fraction.multiply(newSlope, xCalc, mx, calc1, calc2, calc3, calc4, calc5, calc6);
    do mx.setPos(~(mx.pos()));
    do newE.setB(mx);
    return newE;
	}

	function Equation convertFromStandardToSlopeIntercept(Equation oldE){
		var Equation newE;
		var Fraction O, newB;

		let xCalc = oldE.x();
    let yCalc = oldE.y();
    let bCalc = oldE.b();
    let newB = Fraction.new(Const.i1(), Const.i1());
    let newE = Equation.new(1, Const.sI());
    let O = Const.f0();

    if (xCalc.equals(O) & yCalc.equals(O)){ // throw an error if both x and y are 0
      do Out.ln("x and y cannot both be 0");
      do Sys.error(3);
    }

    if (bCalc.equals(O)) { // if b is 0, it remains 0
      do newE.setB(O);
    }
    if ((xCalc.equals(O) | yCalc.equals(O)) & ~(xCalc.equals(yCalc))){ // x=0 XOR y=0; m becomes 0
      do newE.setSlope(O);
    }
    if (yCalc.equals(O)) { // y is 0
      do newE.setIsVertical(true);
      if (bCalc.equals(O)) { // both y and b are 0
        do newE.setIsYAxis(true);
      } else { // just y is 0
        do bCalc.dividedBy(xCalc, newB);
        do newE.setB(newB);
      }
    } else { // y is not 0
      if (~(bCalc.equals(O))){ // both y and b are not 0; b becomes b/y1
        do bCalc.dividedBy(yCalc, newB);
        do newE.setB(newB);
      }
      if (~(xCalc.equals(O))){ // both y and x are not 0;
        do xCalc.dividedBy(yCalc, tempCalc1);
        do tempCalc1.setPos(~(tempCalc1.pos()));
        do newE.setSlope(tempCalc1);
      } else { // y is not 0 but x is 0;
        do newE.setIsHorizontal(true);
        if (bCalc.equals(O)) { // y is not 0 but both x and b are 0;
          do newE.setIsXAxis(true);
        }
      }
    }
    return newE;
	}

	/** Uses the value of x to solve for y */ // includes horizontal
  method Fraction solveForY(Fraction xPoint){
    if (isHorizontal){
      return bF;
    }
    if (S.equals(format, Const.sI())){
      do Fraction.multiply(mF, xPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
      do tempCalc1.plus(bF, tempCalc2);
      return tempCalc2;
    }
    if (S.equals(format, Const.sP())){
      do xF.minus(xPoint, tempCalc1);
      do Fraction.multiply(mF, tempCalc1, tempCalc2, calc1, calc2, calc3, calc4, calc5, calc6);
      do yF.minus(tempCalc2, tempCalc3);
      return tempCalc3;
    }
    if (S.equals(format, Const.sS())){
      do Fraction.multiply(xF, xPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
      do bF.minus(tempCalc1, tempCalc2);
      do tempCalc2.dividedBy(yF, tempCalc3);
      return tempCalc3;
    }
    do Sys.halt();
    return Const.f1();
  }

	/** Uses the value of y to solve for x */
	method Fraction solveForX(Fraction yPoint){ // includes vertical
		if (isVertical){
			return bF;
		}
		if (S.equals(format, Const.sI())){
			do yPoint.minus(bF, tempCalc1);
			do tempCalc1.dividedBy(mF, tempCalc2);
			return tempCalc2;
		}
		if (S.equals(format, Const.sP())){
			do yF.minus(yPoint, tempCalc1);
			do tempCalc1.dividedBy(mF, tempCalc2);
			do xF.minus(tempCalc2, tempCalc3);
			return tempCalc3;
		}
		if (S.equals(format, Const.sS())){
			do Fraction.multiply(yF, yPoint, tempCalc1, calc1, calc2, calc3, calc4, calc5, calc6);
			do bF.minus(tempCalc1, tempCalc2);
			do tempCalc2.dividedBy(xF, tempCalc3);
			return tempCalc3;
		}
		return Fraction.new(0, 1);
	}

	method Fraction getYIntercept(){
		do tempCalc1.set(Const.i0(), Const.i1());
		let tempCalc2 = solveForY(tempCalc1);
		return tempCalc2;
	}

	method Fraction getXIntercept(){
		do tempCalc1.set(Const.i0(), Const.i1());
		let tempCalc2 = solveForX(tempCalc1);
		return tempCalc2;
	}


	/****************************************************
	**  Methods to build the equation with user input  **
	****************************************************/

	/** Stores the appropriate values from the user based on the chosen equation format */
	method void getValues(){
		if (S.equals(format, Const.sP())){
			do inputVar(Const.sY());
			do inputVar(Const.sM());
			do inputVar(Const.sX());
			return;
		}
		if (S.equals(format, Const.sI())){
			do inputVar(Const.sM());
			do inputVar(Const.sB());
			return;
		}
		if (S.equals(format, Const.sS())){
			do inputVar(Const.sX());
			do inputVar(Const.sY());
			while (xF.equals(Const.f0()) & yF.equals(Const.f0())){
				do Out.ln("x and y cannot both be 0. Please choose another number.");
				do inputVar(Const.sY());
			}
			do inputVar(Const.sB());
			return;
		}
		return;
	}

	/** Retrieves a single value from the user */
	method void inputVar(String v){
		var String xString, yString, bString, mString;
		var Fraction temp;
		if (S.equals(v, Const.sX())){
			let xString = Keyboard.readLine("Enter an x:");
			let xF = Fraction.toFraction(xString);
			let temp = xF;
			let xExists = true;
		}
		if (S.equals(v, Const.sY())){
			let yString = Keyboard.readLine("Enter a y:");
			let yF = Fraction.toFraction(yString);
			let yExists = true;
			let temp = yF;
		}
		if (S.equals(v, Const.sB())){
			let bString = Keyboard.readLine("Enter an intercept:");
			let bF = Fraction.toFraction(bString);
			let bExists = true;
			let temp = bF;
		}
		if (S.equals(v, Const.sM())){
			let mString = Keyboard.readLine("Enter a slope:");
			let mF = Fraction.toFraction(mString);
			let mExists = true;
			let temp = mF;
		}
		return;
	}
}
